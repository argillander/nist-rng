from nistrng import *
import numpy
import sys
class col:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def pack_sequence(sequence: numpy.ndarray) -> numpy.ndarray:
    """
    Pack a sequence of signed integers to its binary 8-bit representation using numpy.
    :param sequence: the integer sequence to pack (in the form of a numpy array, ndarray)
    :return: the sequence packed in 8-bit integer in the form of a numpy array (ndarray)
    """
    return numpy.unpackbits(numpy.array(sequence, dtype=numpy.uint8)).astype(numpy.uint8)


def unpack_sequence(sequence_binary_encoded: numpy.ndarray) -> numpy.ndarray:
    """
    Unpack a sequence of numbers represented with 8-bits to its signed integer representation using numpy.
    :param sequence_binary_encoded: the 8-bit numbers sequence to unpack (in the form of a numpy array, ndarray)
    :return: the sequence unpacked in signed integer in the form of a numpy array (ndarray)
    """
    return numpy.packbits(numpy.array(sequence_binary_encoded)).astype(numpy.uint8)

def run_all_battery(bits: numpy.ndarray, battery: dict,
                    check_eligibility: bool = True) -> []:
    """
    Run all the given tests in the battery with the given bits as input.
    E.g. of a battery of test is the sp800-22r1a test battery.
    :param bits: the sequence (ndarray) of bits encoding the sequence of integers
    :param battery: the battery of test (dict with keys the names and values the classes extending Test) to run on the sequence
    :param check_eligibility: whether to check or not for eligibility. If checked and failed, the associate test returns None
    :return: a list of Result objects zipped each one with its own elapsed time or Nones for each not eligible test (if check is required)
    """
    
    # Run all the tests in the battery by name
    tests_to_skip = ["linear_complexity", "serial", "approximate_entropy", "binary_matrix_rank"]
    results: [] = []
    for name in battery.keys():
        if name in tests_to_skip:
            print(col.WARNING + "SKIPPING " + col.ENDC + name)
            continue
        print("Running ", name)

        results.append(run_by_name_battery(name, bits, battery, check_eligibility))
    return results



if __name__ == "__main__":
    input_seq = []

    if len(sys.argv) < 2:
        print("Usage: nist <inputfile>")
        exit(-1)

    with open(sys.argv[1], "r") as f:
        input_seq = f.read().splitlines()

    input_seq = input_seq

    #input_seq = [int(x) for x in input_seq]


    #print(input_seq)


    # Generate the sequence of integers and pack it in its 8-bit representation
    #sequence = numpy.random.randint(0, 255, 10, dtype=numpy.uint8)
    
    import struct
    #print(input_seq)
    sequence = []
    for i in input_seq:
        x = int(i)
        sequence.extend(list(struct.unpack('4B', struct.pack('>I', x))))
    #print(sequence)

    sequence = numpy.array(sequence)


    binary_sequence = pack_sequence(sequence)
    
    

    # Print sequence
    # print("Random sequence generated by NumPy:")
   #print(sequence)
    # print("Random sequence generated by NumPy encoded in 8-bit signed format:")
    #print(binary_sequence)
    # print("Original sequence taken back by unpacking (to check the correctness of packing process:")
    #print(unpack_sequence(binary_sequence))
    #print((binary_sequence))

    print("Length of sequence (integers): ")
    print(len(input_seq))

    print("Length of sequence (bytes): ")
    print(len(sequence))

    print("Length of sequence (bits): ")
    print(len(binary_sequence))

    
    #binary_sequence.astype('int32').tofile("binarysequence.bin")



    # Check the eligibility of the test and generate an eligible battery from the default NIST-sp800-22r1a battery
    eligible_battery: dict = check_eligibility_all_battery(binary_sequence, SP800_22R1A_BATTERY)
    # Print the eligible tests
    #print("Eligible test from NIST-SP800-22r1a:")
    #for name in eligible_battery.keys():
    #    print("-" + name)
    # Test the sequence on the eligible tests
    results = run_all_battery(binary_sequence, eligible_battery, False)
    # Print results one by one

    print("Test results:")
    for result, elapsed_time in results:
        if result.passed:
            print("- " + col.OKGREEN + "PASSED" + col.ENDC + " - score: " + str(numpy.round(result.score, 3)) + " - " + result.name + " - elapsed time: " + str(elapsed_time) + " ms")
        else:
            print("- " + col.FAIL + "FAILED" + col.ENDC + " - score: " + str(numpy.round(result.score, 3)) + " - " + result.name + " - elapsed time: " + str(elapsed_time) + " ms")